{
    "lb": {
        "prefix": "lb",
        "body": "lb      $rt, $addr",
        "description": "load byte",
        "scope": "source.mips64"
    },
    "lbu": {
        "prefix": "lbu",
        "body": "lbu     $rt, $addr",
        "description": "load byte unsigned",
        "scope": "source.mips64"
    },
    "sb": {
        "prefix": "sb",
        "body": "sb      $rt, $addr",
        "description": "store byte",
        "scope": "source.mips64"
    },
    "lh": {
        "prefix": "lh",
        "body": "lh      $rt, $addr",
        "description": "load 16",
        "scope": "source.mips64"
    },
    "lhu": {
        "prefix": "lhu",
        "body": "lhu     $rt, $addr",
        "description": "load 16",
        "scope": "source.mips64"
    },
    "sh": {
        "prefix": "sh",
        "body": "sh      $rt, $addr",
        "description": "store 16",
        "scope": "source.mips64"
    },
    "lw": {
        "prefix": "lw",
        "body": "lw      $rt, $addr",
        "description": "load 32",
        "scope": "source.mips64"
    },
    "lwu": {
        "prefix": "lwu",
        "body": "lwu     $rt, $addr",
        "description": "load 32",
        "scope": "source.mips64"
    },
    "sw": {
        "prefix": "sw",
        "body": "sw      $rt, $addr",
        "description": "store 32",
        "scope": "source.mips64"
    },
    "ld": {
        "prefix": "ld",
        "body": "ld      $rt, $addr",
        "description": "load 64",
        "scope": "source.mips64"
    },
    "sd": {
        "prefix": "sd",
        "body": "sd      $rt, $addr",
        "description": "store 64",
        "scope": "source.mips64"
    },
    "l.d": {
        "prefix": "l.d",
        "body": "l.d     $fd, $addr",
        "description": "load 64",
        "scope": "source.mips64"
    },
    "s.d": {
        "prefix": "s.d",
        "body": "s.d     $fd, $addr",
        "description": "store 64",
        "scope": "source.mips64"
    },
    "halt": {
        "prefix": "halt",
        "body": "halt",
        "description": "stop the program",
        "scope": "source.mips64"
    },
    "daddi": {
        "prefix": "daddi",
        "body": "daddi   $rt, $rs, $val",
        "description": "add immediate",
        "scope": "source.mips64"
    },
    "daddui": {
        "prefix": "daddui",
        "body": "daddui  $rt, $rs, $val",
        "description": "add immediate unsigned",
        "scope": "source.mips64"
    },
    "andi": {
        "prefix": "andi",
        "body": "andi    $rt, $rs, $val",
        "description": "logical and immediate",
        "scope": "source.mips64"
    },
    "ori": {
        "prefix": "ori",
        "body": "ori     $rt, $rs, $val",
        "description": "logical or immediate",
        "scope": "source.mips64"
    },
    "xori": {
        "prefix": "xori",
        "body": "xori    $rt, $rs, $val",
        "description": "exclusive or immediate",
        "scope": "source.mips64"
    },
    "lui": {
        "prefix": "lui",
        "body": "lui     $rt, $val",
        "description": "load upper half of register immediate",
        "scope": "source.mips64"
    },
    "slti": {
        "prefix": "slti",
        "body": "slti    $rt, $rs, $val",
        "description": "set if less than or equal immediate",
        "scope": "source.mips64"
    },
    "sltiu": {
        "prefix": "sltiu",
        "body": "sltiu   $rt, $rs, $val",
        "description": "set if less than or equal immediate unsigned",
        "scope": "source.mips64"
    },
    "beq": {
        "prefix": "beq",
        "body": "beq     $rs, $rt, $off",
        "description": "branch if pair of registers are equal",
        "scope": "source.mips64"
    },
    "bne": {
        "prefix": "bne",
        "body": "bne     $rs, $rt, $off",
        "description": "branch if pair of registers are not equal",
        "scope": "source.mips64"
    },
    "beqz": {
        "prefix": "beqz",
        "body": "beqz    $rs, $off",
        "description": "branch if register is equal to zero",
        "scope": "source.mips64"
    },
    "bnez": {
        "prefix": "bnez",
        "body": "bnez    $rs, $off",
        "description": "branch if register is not equal to zero",
        "scope": "source.mips64"
    },
    "j": {
        "prefix": "j",
        "body": "j       $target",
        "description": "jump to address",
        "scope": "source.mips64"
    },
    "jr": {
        "prefix": "jr",
        "body": "jr      $rs",
        "description": "jump to address in register",
        "scope": "source.mips64"
    },
    "jal": {
        "prefix": "jal",
        "body": "jal     $target",
        "description": "jump and link to address (call subroutine)",
        "scope": "source.mips64"
    },
    "jalr": {
        "prefix": "jalr",
        "body": "jalr    $rd, $rs",
        "description": "jump and link to address in register (call subroutine)",
        "scope": "source.mips64"
    },
    "dsll": {
        "prefix": "dsll",
        "body": "dsll    $rd, $rt, $sa",
        "description": "shift left logical",
        "scope": "source.mips64"
    },
    "dsrl": {
        "prefix": "dsrl",
        "body": "dsrl    $rd, $rt, $sa",
        "description": "shift right logical",
        "scope": "source.mips64"
    },
    "dsra": {
        "prefix": "dsra",
        "body": "dsra    $rd, $rt, $sa",
        "description": "shift right arithmetic",
        "scope": "source.mips64"
    },
    "dsllv": {
        "prefix": "dsllv",
        "body": "dsllv   $rd, $rt, $rs",
        "description": "shift left logical by variable amount",
        "scope": "source.mips64"
    },
    "dsrlv": {
        "prefix": "dsrlv",
        "body": "dsrlv   $rd, $rt, $rs",
        "description": "shift right logical by variable amount",
        "scope": "source.mips64"
    },
    "dsrav": {
        "prefix": "dsrav",
        "body": "dsrav   $rd, $rt, $rs",
        "description": "shift right arithmetic by variable amount",
        "scope": "source.mips64"
    },
    "movz": {
        "prefix": "movz",
        "body": "movz    $rd, $rs, $rt",
        "description": "move if register equals zero",
        "scope": "source.mips64"
    },
    "movn": {
        "prefix": "movn",
        "body": "movn    $rd, $rs, $rt",
        "description": "move if register not equal to zero",
        "scope": "source.mips64"
    },
    "nop": {
        "prefix": "nop",
        "body": "nop",
        "description": "no operation",
        "scope": "source.mips64"
    },
    "and": {
        "prefix": "and",
        "body": "and     $rd, $rs, $rt",
        "description": "logical and",
        "scope": "source.mips64"
    },
    "or": {
        "prefix": "or",
        "body": "or      $rd, $rs, $rt",
        "description": "logical or",
        "scope": "source.mips64"
    },
    "xor": {
        "prefix": "xor",
        "body": "xor     $rd, $rs, $rt",
        "description": "logical xor",
        "scope": "source.mips64"
    },
    "slt": {
        "prefix": "slt",
        "body": "slt     $rd, $rs, $rt",
        "description": "set if less than",
        "scope": "source.mips64"
    },
    "sltu": {
        "prefix": "sltu",
        "body": "sltu    $rd, $rs, $rt",
        "description": "set if less than unsigned",
        "scope": "source.mips64"
    },
    "dadd": {
        "prefix": "dadd",
        "body": "dadd    $rd, $rs, $rt",
        "description": "add integers",
        "scope": "source.mips64"
    },
    "daddu": {
        "prefix": "daddu",
        "body": "daddu   $rd, $rs, $rt",
        "description": "add integers unsigned",
        "scope": "source.mips64"
    },
    "dsub": {
        "prefix": "dsub",
        "body": "dsub    $rd, $rs, $rt",
        "description": "subtract integers",
        "scope": "source.mips64"
    },
    "dsubu": {
        "prefix": "dsubu",
        "body": "dsubu   $rd, $rs, $rt",
        "description": "subtract integers unsigned",
        "scope": "source.mips64"
    },
    "dmul": {
        "prefix": "dmul",
        "body": "dmul    $rd, $rs, $rt",
        "description": "signed integer multiplication",
        "scope": "source.mips64"
    },
    "dmulu": {
        "prefix": "dmulu",
        "body": "dmulu   $rd, $rs, $rt",
        "description": "unsigned integer multiplication",
        "scope": "source.mips64"
    },
    "ddiv": {
        "prefix": "ddiv",
        "body": "ddiv    $rd, $rs, $rt",
        "description": "signed integer division",
        "scope": "source.mips64"
    },
    "ddivu": {
        "prefix": "ddivu",
        "body": "ddivu   $rd, $rs, $rt",
        "description": "unsigned integer division",
        "scope": "source.mips64"
    },
    "add.d": {
        "prefix": "add.d",
        "body": "add.d   $fd, $fs, $ft",
        "description": "add floating",
        "scope": "source.mips64"
    },
    "sub.d": {
        "prefix": "sub.d",
        "body": "sub.d   $fd, $fs, $ft",
        "description": "subtract floating",
        "scope": "source.mips64"
    },
    "mul.d": {
        "prefix": "mul.d",
        "body": "mul.d   $fd, $fs, $ft",
        "description": "multiply floating",
        "scope": "source.mips64"
    },
    "div.d": {
        "prefix": "div.d",
        "body": "div.d   $fd, $fs, $ft",
        "description": "divide floating",
        "scope": "source.mips64"
    },
    "mov.d": {
        "prefix": "mov.d",
        "body": "mov.d   $fd, $fs",
        "description": "move floating",
        "scope": "source.mips64"
    },
    "cvt.d.l": {
        "prefix": "cvt.d.l",
        "body": "cvt.d.l $fd, $fs",
        "description": "convert 64",
        "scope": "source.mips64"
    },
    "cvt.l.d": {
        "prefix": "cvt.l.d",
        "body": "cvt.l.d $fd, $fs",
        "description": "convert double floating",
        "scope": "source.mips64"
    },
    "c.lt.d": {
        "prefix": "c.lt.d",
        "body": "c.lt.d  $fs, $ft",
        "description": "set FP flag if less than",
        "scope": "source.mips64"
    },
    "c.le.d": {
        "prefix": "c.le.d",
        "body": "c.le.d  $fs, $ft",
        "description": "set FP flag if less than or equal to",
        "scope": "source.mips64"
    },
    "c.eq.d": {
        "prefix": "c.eq.d",
        "body": "c.eq.d  $fs, $ft",
        "description": "set FP flag if equal to",
        "scope": "source.mips64"
    },
    "bc1f": {
        "prefix": "bc1f",
        "body": "bc1f    $off",
        "description": "branch to address if FP flag is FALSE",
        "scope": "source.mips64"
    },
    "bc1t": {
        "prefix": "bc1t",
        "body": "bc1t    $off",
        "description": "branch to address if FP flag is TRUE",
        "scope": "source.mips64"
    },
    "mtc1": {
        "prefix": "mtc1",
        "body": "mtc1    $rt, $fs",
        "description": "move data from integer register to floating",
        "scope": "source.mips64"
    },
    "mfc1": {
        "prefix": "mfc1",
        "body": "mfc1   $rt, $fs",
        "description": "move data from floating",
        "scope": "source.mips64"
    }
}